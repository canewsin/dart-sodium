import 'dart:ffi';
import 'dart:typed_data';
import 'package:dart_sodium/src/ffi_helper.dart';

import 'src/bindings/pwhash.dart' as bindings;

export 'src/bindings/pwhash.dart' show OpsLimit, MemLimit;

/// Produces strong password hashes with the Argon2 function, ready for storage.
/// It also handles salting.
/// Sensible values for [opslimit] and [memlimit] can be found in the abstract classes
/// [OpsLimit] and [MemLimit].
/// ```
/// final passwd = ascii.encode("my password");
/// final pwhash = pwHashStr(paswd, OpsLimit.moderate, MemLimit.moderate);
/// ```
Uint8List store(Uint8List passwd, int opslimit, int memlimit) {
  Pointer<Uint8> out;
  Pointer<Uint8> passwdCstr;
  try {
    out = allocate(count: bindings.strBytes);
    passwdCstr = BufferToCString(passwd);
    final hashResult =
        bindings.store(out, passwdCstr, passwd.length, opslimit, memlimit);
    if (hashResult < 0) {
      throw Exception("Password hashing failed");
    }
    return CStringToBuffer(out, bindings.strBytes);
  } finally {
    out?.free();
    passwdCstr?.free();
  }
}

/// Verifys [passwd] with its [hash] generated by [str].
bool storeVerify(Uint8List hash, Uint8List passwd) {
  Pointer<Uint8> hashPtr;
  Pointer<Uint8> passwdPtr;
  try {
    hashPtr = BufferToCString(hash);
    passwdPtr = BufferToCString(passwd);
    final verifyResult =
        bindings.storeVerify(hashPtr, passwdPtr, passwd.length);
    return verifyResult == 0;
  } finally {
    hashPtr?.free();
    passwdPtr?.free();
  }
}
