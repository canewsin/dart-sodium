import 'dart:ffi';
import 'dart:typed_data';
import 'ffi_helper.dart';

import 'bindings/pwhash.dart' as bindings;

export 'bindings/pwhash.dart' show OpsLimit, MemLimit;

/// Produces strong password hashes with the Argon2 function, ready for storage.
/// It also handles salting.
/// Sensible values for [opslimit] and [memlimit] can be found in the abstract classes
/// [OpsLimit] and [MemLimit].
/// ```
/// final passwd = ascii.encode("my password");
/// final pwhash = pwHashStr(paswd, OpsLimit.moderate, MemLimit.moderate);
/// ```
Uint8List store(Uint8List passwd, int opslimit, int memlimit) {
  if (passwd.length > bindings.passwdMax) {
    throw ArgumentError("[passwd] is too long");
  }
  if (passwd.length < bindings.passwdMin) {
    throw ArgumentError("[passwd] is too short");
  }
  if (opslimit > bindings.OpsLimit.max) {
    throw ArgumentError("[opslimit] is too big");
  }
  if (opslimit < bindings.OpsLimit.min) {
    throw ArgumentError("[opslimit] is too small");
  }
  if (memlimit > bindings.MemLimit.max) {
    throw ArgumentError("[memlimit] is too big");
  }
  if (memlimit < bindings.MemLimit.min) {
    throw ArgumentError("[memlimit] is too small");
  }
  final out = allocate<Uint8>(count: bindings.strBytes);
  final passwdCstr = BufferToCString(passwd);
  try {
    final hashResult =
        bindings.store(out, passwdCstr, passwd.length, opslimit, memlimit);
    if (hashResult < 0) {
      throw Exception("Password hashing failed");
    }
    final outBuf = Uint8List(bindings.strBytes);
    var i = 0;
    for (; i < bindings.strBytes; i++) {
      final elem = out.elementAt(i).load<int>();
      outBuf[i] = elem;
      if (elem == 0) {
        break;
      }
    }
    if (i + 1 < bindings.strBytes) {
      return outBuf.sublist(0, i);
    }
    return outBuf;
  } finally {
    out.free();
    passwdCstr.free();
  }
}

/// Verifys [passwd] with its [hash] generated by [storage].
bool verify(Uint8List hash, Uint8List passwd) {
  if (passwd.length > bindings.passwdMax) {
    throw ArgumentError("[passwd] is too long");
  }
  if (passwd.length < bindings.passwdMin) {
    throw ArgumentError("[passwd] is too short");
  }
  if (hash.length > bindings.bytesMax) {
    throw ArgumentError("[hash] is too long");
  }
  if (hash.length < bindings.bytesMin) {
    throw ArgumentError("[hash] is too short");
  }
  final hashPtr = BufferToCString(hash);
  final passwdPtr = BufferToCString(passwd);
  try {
    final verifyResult =
        bindings.storeVerify(hashPtr, passwdPtr, passwd.length);
    return verifyResult == 0;
  } finally {
    hashPtr.free();
    passwdPtr.free();
  }
}
