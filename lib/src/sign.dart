import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi_helper/ffi_helper.dart';
import 'internal_helpers.dart';

import 'bindings/sign.dart' as bindings;

class SignError extends Error {
  @override
  String toString() {
    return 'Failed to sign message';
  }
}

class UpdateException implements Exception {
  @override
  String toString() {
    return 'Failed to update state of MultiPartSigner';
  }
}

class InvalidSignatureError extends ArgumentError {
  @override
  String toString() {
    return 'The signature appears to be invalid';
  }
}

class SignInitException implements Exception {
  @override
  String toString() {
    return 'Failed to initialize MultiPartSigner';
  }
}

/// Signs [message] with [secretKey]. [secretKey] must be [secretKeyBytes] long.
Uint8List sign(Uint8List message, Uint8List secretKey) {
  final skPtr = Uint8Array.fromTypedList(secretKey);
  final messagePtr = Uint8Array.fromTypedList(message);
  final signedMessagePtr =
      Uint8Array.allocate(count: message.length + bindings.signBytes);

  final result = bindings.sign(signedMessagePtr.rawPtr, nullptr.cast(),
      messagePtr.rawPtr, message.length, skPtr.rawPtr);

  skPtr.freeZero();
  messagePtr.free();
  signedMessagePtr.free();

  if (result != 0) {
    throw SignError();
  }
  return Uint8List.fromList(signedMessagePtr.view);
}

/// Verifies the signature of [signedMessage] generated by [sign] and extracts the message.
/// Throws [InvalidSignatureError] when signature is invalid. When [onError] is provided,
/// no Exception will be thrown and null will be returned.
Uint8List open(Uint8List signedMessage, Uint8List publicKey,
    {Function() onError}) {
  final pkPtr = Uint8Array.fromTypedList(publicKey);
  final signedMessagePtr = Uint8Array.fromTypedList(signedMessage);
  final messagePtr =
      Uint8Array.allocate(count: signedMessage.length - bindings.signBytes);

  final result = bindings.signOpen(messagePtr.rawPtr, nullptr.cast(),
      signedMessagePtr.rawPtr, signedMessage.length, pkPtr.rawPtr);

  pkPtr.freeZero();
  messagePtr.free();
  signedMessagePtr.free();

  if (result != 0) {
    if (onError == null) {
      throw InvalidSignatureError();
    }
    onError();
    return null;
  }
  return Uint8List.fromList(messagePtr.view);
}

/// Initializes state for signing a multi-part message.
/// Throws [SignInitException] when initialization fails.
Uint8List signInit() {
  final statePtr = Uint8Array.allocate(count: bindings.stateBytes);
  final result = bindings.signInit(statePtr.rawPtr);

  final state = Uint8List.fromList(statePtr.view);
  statePtr.freeZero();
  if (result != 0) {
    throw SignInitException();
  }
  return state;
}

/// Updates [state] with [message].
/// Call [update] for every part of the message.
/// Throws [UpdateException] when updating the state fails.
void update(Uint8List state, Uint8List message) {
  final statePtr = Uint8Array.fromTypedList(state);
  final messagePtr = Uint8Array.fromTypedList(message);

  final result =
      bindings.signUpdate(statePtr.rawPtr, messagePtr.rawPtr, message.length);
  state.setAll(0, statePtr.view);
  statePtr.freeZero();
  messagePtr.free();
  if (result != 0) {
    throw UpdateException;
  }
}

/// Generates a signature which takes every part of the message into account.
/// [secretKey] must be [secretKeyBytes] long.
/// Throws [SignError] when generating signature fails.
Uint8List create(Uint8List state, Uint8List secretKey) {
  final statePtr = Uint8Array.fromTypedList(state);
  final signPtr = Uint8Array.allocate(count: bindings.signBytes);
  final skPtr = Uint8Array.allocate(count: bindings.secretKeyBytes)
    ..view.setAll(0, secretKey);

  final result = bindings.signFinal(
      statePtr.rawPtr, signPtr.rawPtr, nullptr.cast(), skPtr.rawPtr);

  statePtr.freeZero();
  signPtr.free();
  skPtr.freeZero();

  if (result != 0) {
    throw SignError();
  }
  return Uint8List.fromList(signPtr.view);
}

/// Verifies [signature] of a multi-part message generated by [create].
bool verify(Uint8List state, Uint8List signature, Uint8List publicKey) {
  final statePtr = Uint8Array.fromTypedList(state);
  final signPtr = Uint8Array.allocate(count: bindings.signBytes)
    ..view.setAll(0, signature);
  final pkPtr = Uint8Array.allocate(count: bindings.publicKeyBytes)
    ..view.setAll(0, publicKey);

  final result =
      bindings.signFinalVerify(statePtr.rawPtr, signPtr.rawPtr, pkPtr.rawPtr);
  return result == 0;
}
