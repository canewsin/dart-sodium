import 'dart:typed_data';
import 'dart:ffi';
import 'ffi_helper.dart';

import 'bindings/secretbox.dart' as bindings;

/// Encrypts messages with the given key.
class SecretBox {
  /// Generates a random key with the correct length.
  static Uint8List keyGen() {
    final Pointer<Uint8> key = allocate(count: bindings.keyBytes);
    try {
      bindings.keyGen(key);
      return CStringToBuffer(key, bindings.keyBytes);
    } finally {
      key.free();
    }
  }

  static final nonceBytes = bindings.nonceBytes;
  static final keyBytes = bindings.keyBytes;

  final Pointer<Uint8> _key;
  SecretBox(Uint8List key) : _key = BufferToCString(key) {
    if (key.length != bindings.keyBytes) {
      _key.free();
      throw Exception("Key hasn't expected length");
    }
  }

  /// Encrypts a message using the provided nonce / initialization vector.
  /// This nonce can be safely generated randomly (with a cryptographic
  /// random number generator like [random.buffer]) or be obtained by an atomic counter.
  Uint8List easy(Uint8List msg, Uint8List nonce) {
    assert(nonce.length == bindings.nonceBytes,
        "Nonce must be of length [nonceBytes]");
    final cypherTextLen = bindings.macBytes + msg.length;
    final cypherText = allocate<Uint8>(count: cypherTextLen);
    final msgPtr = BufferToCString(msg);
    final noncePtr = BufferToCString(nonce);
    try {
      final secretBoxResult =
          bindings.easy(cypherText, msgPtr, msg.length, noncePtr, _key);
      if (secretBoxResult == -1) {
        throw Exception("Encrypting failed");
      }
      return CStringToBuffer(cypherText, cypherTextLen);
    } finally {
      cypherText.free();
      msgPtr.free();
      noncePtr.free();
    }
  }

  /// Decrypts ciphertexts generated by [easy]
  Uint8List openEasy(Uint8List cypherText, Uint8List nonce) {
    assert(nonce.length == bindings.nonceBytes,
        "Nonce must be of length [nonceBytes]");
    final msgLen = cypherText.length - bindings.macBytes;
    final msgPtr = allocate<Uint8>(count: msgLen);
    final cPtr = BufferToCString(cypherText);
    final noncePtr = BufferToCString(nonce);
    try {
      final result =
          bindings.openEasy(msgPtr, cPtr, cypherText.length, noncePtr, _key);
      if (result == -1) {
        throw Exception("Decrypting failed");
      }
      return CStringToBuffer(msgPtr, msgLen);
    } finally {
      cPtr.free();
      noncePtr.free();
      msgPtr.free();
    }
  }

  /// Closes SecretBox. Call [close] to avoid memory leaks.
  void close() {
    _key.free();
  }
}
