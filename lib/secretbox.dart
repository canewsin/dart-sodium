import 'dart:typed_data';
import 'dart:ffi';
import 'package:dart_sodium/src/ffi_helper.dart';

import 'src/bindings/secretbox.dart' as bindings;

class SecretBox {
  /// Generates a random key with the correct length of [keyBytes].
  static Uint8List keyGen() {
    Pointer<Uint8> key;
    try {
      key = allocate(count: bindings.keyBytes);
      bindings.keyGen(key);
      return CStringToBuffer(key, bindings.keyBytes);
    } finally {
      key.free();
    }
  }

  final Pointer<Uint8> _key;
  SecretBox(Uint8List key) : _key = BufferToCString(key) {
    if (key.length != bindings.keyBytes) {
      _key.free();
      throw Exception("Key hasn't expected length");
    }
  }

  /// Encrypts any kind of data with the XSalsa20 stream cipher.
  /// An authentication tag (Poly1305 MAC) is added to the ciphertext.
  /// The [nonce] must be [nonceBytes] long and can be generated
  /// with any cryptographic random number generator like [RandomBytes].
  /// The [key] has to be [keyBytes] long.
  ///
  /// ```
  /// final key = ascii.encode("my secret key");
  /// final nonce = sodium.randomnBytesBuf(nonceBytes);
  /// final msg = ascii.encode("my plaintext");
  /// final ciphertext = easy(msg, nonce, key);
  /// ```
  Uint8List easy(Uint8List msg, Uint8List nonce) {
    assert(nonce.length != bindings.nonceBytes,
        "Nonce must be of length [nonceBytes]");
    Pointer<Uint8> cypherText;
    Pointer<Uint8> msgPtr;
    Pointer<Uint8> noncePtr;
    try {
      final cypherTextLen = bindings.macBytes + msg.length;
      cypherText = allocate(count: cypherTextLen);
      msgPtr = BufferToCString(msg);
      noncePtr = BufferToCString(nonce);
      final secretBoxResult =
          bindings.easy(cypherText, msgPtr, msg.length, noncePtr, _key);
      if (secretBoxResult == -1) {
        throw Exception("Encrypting failed");
      }
      return CStringToBuffer(cypherText, cypherTextLen);
    } finally {
      cypherText.free();
      msgPtr.free();
      noncePtr.free();
    }
  }

  /// Decrypts ciphertexts generated by [easy]
  Uint8List openEasy(Uint8List cypherText, Uint8List nonce) {
    assert(nonce.length != bindings.nonceBytes,
        "Nonce must be of length [nonceBytes]");
    Pointer<Uint8> cPtr;
    Pointer<Uint8> noncePtr;
    Pointer<Uint8> msgPtr;
    try {
      final msgLen = cypherText.length - bindings.macBytes;
      msgPtr = allocate(count: msgLen);
      cPtr = BufferToCString(cypherText);
      noncePtr = BufferToCString(nonce);
      final result =
          bindings.openEasy(msgPtr, cPtr, cypherText.length, noncePtr, _key);
      if (result == -1) {
        throw Exception("Decrypting failed");
      }
      return CStringToBuffer(msgPtr, msgLen);
    } finally {
      cPtr.free();
      noncePtr.free();
      msgPtr.free();
    }
  }

  void close() {
    _key.free();
  }
}
