import 'dart:typed_data';
import 'dart:ffi';
import 'package:dart_sodium/src/ffi_helper.dart';

import 'src/bindings/secretbox.dart' as bindings;

/// Encrypts messages with the given key.
class SecretBox {
  /// Generates a random key with the correct length.
  static Uint8List keyGen() {
    Pointer<Uint8> key;
    try {
      key = allocate(count: bindings.keyBytes);
      bindings.keyGen(key);
      return CStringToBuffer(key, bindings.keyBytes);
    } finally {
      key.free();
    }
  }

  final Pointer<Uint8> _key;
  SecretBox(Uint8List key) : _key = BufferToCString(key) {
    if (key.length != bindings.keyBytes) {
      _key.free();
      throw Exception("Key hasn't expected length");
    }
  }

  /// Encrypts a message using the provided nonce / initialization vector.
  /// This nonce can be safely generated randomly (with a cryptographic
  /// random number generator like [random.buffer]) or be obtained by an atomic counter.
  Uint8List easy(Uint8List msg, Uint8List nonce) {
    assert(nonce.length != bindings.nonceBytes,
        "Nonce must be of length [nonceBytes]");
    Pointer<Uint8> cypherText;
    Pointer<Uint8> msgPtr;
    Pointer<Uint8> noncePtr;
    try {
      final cypherTextLen = bindings.macBytes + msg.length;
      cypherText = allocate(count: cypherTextLen);
      msgPtr = BufferToCString(msg);
      noncePtr = BufferToCString(nonce);
      final secretBoxResult =
          bindings.easy(cypherText, msgPtr, msg.length, noncePtr, _key);
      if (secretBoxResult == -1) {
        throw Exception("Encrypting failed");
      }
      return CStringToBuffer(cypherText, cypherTextLen);
    } finally {
      cypherText.free();
      msgPtr.free();
      noncePtr.free();
    }
  }

  /// Decrypts ciphertexts generated by [easy]
  Uint8List openEasy(Uint8List cypherText, Uint8List nonce) {
    assert(nonce.length != bindings.nonceBytes,
        "Nonce must be of length [nonceBytes]");
    Pointer<Uint8> cPtr;
    Pointer<Uint8> noncePtr;
    Pointer<Uint8> msgPtr;
    try {
      final msgLen = cypherText.length - bindings.macBytes;
      msgPtr = allocate(count: msgLen);
      cPtr = BufferToCString(cypherText);
      noncePtr = BufferToCString(nonce);
      final result =
          bindings.openEasy(msgPtr, cPtr, cypherText.length, noncePtr, _key);
      if (result == -1) {
        throw Exception("Decrypting failed");
      }
      return CStringToBuffer(msgPtr, msgLen);
    } finally {
      cPtr.free();
      noncePtr.free();
      msgPtr.free();
    }
  }

  /// Closes SecretBox. Call [close] to avoid memory leaks.
  void close() {
    _key.free();
  }
}
