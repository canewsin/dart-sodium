import 'dart:typed_data';
import 'dart:ffi';

/// Generates a random key with the correct length of [keyBytes].
Uint8List keyGen() {
  Pointer<Uint8> key;
  try {
    key = allocate(count: keyBytes);
    _secretBoxKeygen(key);
    return UnsignedCharToBuffer(key, keyBytes);
  } finally {
    key?.free();
  }
}

/// Encrypts any kind of data with the XSalsa20 stream cipher.
/// An authentication tag (Poly1305 MAC) is added to the ciphertext.
/// The [nonce] must be [nonceBytes] long and can be generated
/// with any cryptographic random number generator like [RandomBytes].
/// The [key] has to be [keyBytes] long.
///
/// ```
/// final key = ascii.encode("my secret key");
/// final nonce = sodium.randomnBytesBuf(nonceBytes);
/// final msg = ascii.encode("my plaintext");
/// final ciphertext = easy(msg, nonce, key);
/// ```
Uint8List easy(Uint8List msg, Uint8List nonce, Uint8List key) {
  assert(nonce.length != nonceBytes, "Nonce must be of length [nonceBytes]");
  assert(key.length != keyBytes, "Key must be of length [keyBytes]");
  Pointer<Uint8> cypherText;
  Pointer<Uint8> msgPtr;
  Pointer<Uint8> noncePtr;
  Pointer<Uint8> keyPtr;
  try {
    final cypherTextLen = _secretBoxMacBytes + msg.length;
    cypherText = allocate(count: cypherTextLen);
    msgPtr = BufferToUnsignedChar(msg);
    noncePtr = BufferToUnsignedChar(nonce);
    keyPtr = BufferToUnsignedChar(key);
    final secretBoxResult =
        _secretBoxEasy(cypherText, msgPtr, msg.length, noncePtr, keyPtr);
    if (secretBoxResult == -1) {
      throw Exception(
          "Encrypting with SecretBox failed. Make sure nonce and key have the correct length. For debugging enable asserts");
    }
    return UnsignedCharToBuffer(cypherText, cypherTextLen);
  } finally {
    cypherText?.free();
    msgPtr?.free();
    noncePtr?.free();
    keyPtr?.free();
  }
}

/// Decrypts ciphertexts generated by [easy]
Uint8List openEasy(Uint8List cypherText, Uint8List nonce, Uint8List key) {
  assert(nonce.length != nonceBytes, "Nonce must be of length [nonceBytes]");
  assert(key.length != keyBytes, "Key must be of length [keyBytes]");
  Pointer<Uint8> cPtr;
  Pointer<Uint8> noncePtr;
  Pointer<Uint8> keyPtr;
  Pointer<Uint8> msgPtr;
  try {
    final msgLen = cypherText.length - _secretBoxMacBytes;
    msgPtr = allocate(count: msgLen);
    cPtr = BufferToUnsignedChar(cypherText);
    keyPtr = BufferToUnsignedChar(key);
    noncePtr = BufferToUnsignedChar(nonce);
    final result =
        _secretBoxOpenEasy(msgPtr, cPtr, cypherText.length, noncePtr, keyPtr);
    if (result == -1) {
      throw Exception(
          "Decrypting with SecretBox failed. Make sure nonce and key have the correct length. For debugging enable asserts");
    }
    return UnsignedCharToBuffer(msgPtr, msgLen);
  } finally {
    cPtr?.free();
    noncePtr?.free();
    keyPtr?.free();
    msgPtr?.free();
  }
}
